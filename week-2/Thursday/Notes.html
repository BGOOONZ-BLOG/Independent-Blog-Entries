<h1 id="notes"><strong>Notes</strong></h1>
<h2 id="all-about-scope-in-javscript"><strong>All About Scope in Javscript</strong></h2>
<p>The <strong><code>scope</code></strong> of a program in JS is the set of variables that are available for use within the program.</p>
<p><strong>Advantages of utilizing scope</strong></p>
<ul>
<li><strong><code>Security</code></strong> : Adds security by ensuring variables can only be access by pre-defined parts of our program.</li>
<li><strong><code>Reduced Variable Name Collisions</code></strong> : Restricts re-using variable names; helps prevent overwriting variable names.</li>
</ul>
<p><strong>Different Kinds of Scope</strong></p>
<ul>
<li><strong><code>Global Scope</code></strong>
<ul>
<li>The widest and outermost scope.</li>
<li>Represented by the <strong><code>window</code></strong> obj in the browser and the <strong><code>global</code></strong> obj in Node.js.</li>
<li>Try to avoid these as much as possible.</li>
</ul></li>
<li><strong><code>Local Scope</code></strong>
<ul>
<li>Scope within a function.</li>
<li>Includes function arguments, variables declared within function, also <strong>any variables already declared when the function was defined</strong></li>
</ul></li>
<li><strong><code>Block Scope</code></strong>
<ul>
<li>Contents within curly braces.</li>
</ul></li>
</ul>
<p><strong>Scope Chaining: Variables and Scope</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> name <span class="op">=</span> <span class="st">&quot;Fiona&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">// we aren&#39;t passing in or defining and variables</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">function</span> <span class="at">hungryHippo</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(name <span class="op">+</span> <span class="st">&quot; is hungry!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="at">hungryHippo</span>()<span class="op">;</span> <span class="co">// =&gt; &quot;Fiona is hungry&quot;</span></a></code></pre></div>
<ul>
<li>A key scoping rule is that an inner scope <strong>does</strong> have access to variables in the outer scope.</li>
<li><strong><code>Scope Chaining</code></strong> : When a variable is not found within the immediate scope, JS will keep searching outwards until it matches the one we are referencing.</li>
<li>Important to note while inner scopes can search outwards, outer scopes cannot reference inner variables!</li>
</ul>
<p><strong>Lexical Scope</strong></p>
<ul>
<li><p><strong><code>Lexing Time</code></strong> : When you run a piece of JS code that is parsed before it is run.</p></li>
<li><p>JS language does not have dynamic scope.</p></li>
</ul>
<hr />
<h2 id="different-variables-in-javascript"><strong>Different Variables in Javascript</strong></h2>
<ul>
<li><em>A variable always evaluates to the value it contains no matter how you declare it.</em></li>
</ul>
<p><strong>The different ways to declare variables</strong></p>
<ul>
<li><strong><code>let</code></strong> : can be re-assigned; block-scoped.</li>
<li><strong><code>const</code></strong> : no re-assignment; block scoped.</li>
<li><strong><code>var</code></strong> : May or may not be re-assigned; scoped to a function.</li>
</ul>
<p><strong>Hoisting and Scoping with Variables</strong></p>
<p><strong><code>Hoisting</code></strong> is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution.</p>
<p><strong>Function-Scoped Variables</strong></p>
<ul>
<li>As we learned, var creates function-scoped variables, this means our declared var keyword variable will be confined to the scope of our current function.</li>
</ul>
<p><strong>Hoisting with function-scoped variables</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">test</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="co">// var hoistedVar;</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(hoistedVar)<span class="op">;</span> <span class="co">// =&gt;  undefined</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">var</span> hoistedVar <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="op">}</span></a></code></pre></div>
<ul>
<li>Even though we initially declared &amp; initizalized our variable underneath the console.log var variables are “hoisted” to the top, but only in declaration.</li>
</ul>
<p><strong>Block-Scoped Variables</strong></p>
<p>Things that create block-scopes:</p>
<ul>
<li>If Statements</li>
<li>While Loops</li>
<li>Switch Statements</li>
<li>For Loops</li>
</ul>
<p><strong>Properties of Constants</strong></p>
<ul>
<li>They are block-scoped like let.</li>
<li>JS will enforce constants by raising an error if you try to change them.</li>
<li>Constants that are assigned to Reference Types are <strong>mutable</strong></li>
</ul>
<p><strong>Hoisting with block-scoped variables</strong></p>
<ul>
<li>Unlike vars in function scopes, let and const in their block scopes do not get their declarations hoisted.</li>
<li>Instead they are not initalized until their definitions are evaluated - instead of undefined we will get an error.</li>
<li><strong><code>Temporal Dead Zone</code></strong> : The time before a let or const variable is declared.</li>
</ul>
<p><strong>Function Scope vs Block Scope</strong></p>
<ul>
<li>The downside of the flexibility of var is that it can easily overwrite previously declared variables.</li>
<li>The block-scope limitations of let and const were introduced to easily avoid accidentally overwriting variable values.</li>
</ul>
<p><strong>Global Variables</strong></p>
<ul>
<li>Any variables declared without a declaration term will be considered <strong><code>global scope</code></strong>.</li>
<li>Every time a variable is declared on the global scope, the change of collision increases.</li>
<li>Use the proper declarations to manage your code: Avoid being a sloppy programmer!</li>
</ul>
<hr />
<h2 id="closures"><strong>Closures</strong></h2>
<p><strong>Calculating Closures</strong></p>
<ul>
<li><strong>Closure</strong> : The combination of a function and the lexical environment within which that function is declared.</li>
<li><strong>Use</strong> : A closure is when an inner function uses, or changes, variables in an outer function.</li>
<li>Very important for creativity, flexibility, and security of your code.</li>
<li><strong><code>Lexical Environment</code></strong> : Consists of any variables available within the scope in which a closure was declared (local inner, outer, and global).</li>
</ul>
<p><strong>Closures and Scope</strong> Basic Closure Rules:</p>
<ul>
<li>Closures have access to all variables in it’s lexical environment.</li>
<li>A closure will keep reference to all the variables when it was defined <strong>even if the outer function has returned</strong>.</li>
</ul>
<p><strong>Applications of Closures</strong></p>
<ul>
<li><strong>Private State</strong>
<ul>
<li>JS does not have a way of declaring a function as exclusively private, however we can use closures to make a private state.</li>
</ul></li>
<li><p><strong>Passing Arguments Implicitly</strong></p>
<ul>
<li>We can use closures to pass down arguments to helper functions.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">isPalindrome</span>(string) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">function</span> <span class="at">reverse</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">return</span> <span class="va">string</span>.<span class="at">split</span>(<span class="st">&quot;&quot;</span>).<span class="at">reverse</span>().<span class="at">join</span>(<span class="st">&quot;&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="cf">return</span> string <span class="op">===</span> <span class="at">reverse</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="op">}</span></a></code></pre></div></li>
</ul>
<hr />
<h2 id="context-in-javascript"><strong>Context in Javascript</strong></h2>
<ul>
<li><strong><code>Scope</code></strong> : Refers to the visibility and availability of variables.</li>
<li><strong><code>Context</code></strong> : Refers to the value of the <strong><code>this</code></strong> keyword when code is executed.</li>
</ul>
<p><strong>What about <code>this</code> ?</strong></p>
<ul>
<li><strong><code>This</code></strong> : Keyword that exists in every function and evaluates to the object that is currently invoking that function.</li>
<li><strong>Method-Style Invocation</strong> : syntax goes like <code>object.method(arg)</code>. (i.e. array.push, str.toUpperCase()</li>
<li><strong><code>Context</code></strong> refers to the value of this within a function and <strong><code>this</code></strong> refers to where a function is invoked.</li>
</ul>
<p><strong>Issues with Scope and Context</strong></p>
<ul>
<li>If <code>this</code> is called using normal function style invocation, our output will be the contents of the global object.</li>
</ul>
<p><strong>When Methods have an Unexpected Context</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">let</span> dog <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Bowser&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="dt">changeName</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> <span class="st">&quot;Layla&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="op">};</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">let</span> change <span class="op">=</span> <span class="va">dog</span>.<span class="at">changeName</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="at">change</span>())<span class="op">;</span> <span class="co">// undefined</span></a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="va">console</span>.<span class="at">log</span>(dog)<span class="op">;</span> <span class="co">// { name: &#39;Bowser&#39;, changeName: [Function: changeName] }</span></a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>)<span class="op">;</span> <span class="co">// Object [global] {etc, etc, etc,  name: &#39;Layla&#39;}</span></a></code></pre></div>
<ul>
<li>In the above example we get undefined when we assign our this function to a variable bc there is no obj to reference except the global one!</li>
<li><p><strong><code>global.setTimeout()</code></strong> : popular method of setting a function to run on a timer.</p>
<ul>
<li><p>Accepts a callback and a number of milliseconds to wait before invoking the callback.</p>
<pre><code>```js
let hello = function () {
  console.log(&quot;hello!&quot;);
};

// global. is a method of the global object!
global.setTimeout(hello, 5000); // waits 5 seconds then prints &quot;hello!&quot;
```</code></pre></li>
</ul></li>
</ul>
<p><strong>Strictly Protecting the Global Object</strong></p>
<p>We can run JS in strict mode by tagging <code>use strict</code> at the top of our program.</p>
<ul>
<li>If we try to invoke this on our global function in strict mode we will no longer be able to access it and instead just get undefined.</li>
</ul>
<p><strong>Changing Context using Bind</strong></p>
<p>“The simplest use of <strong><code>bind()</code></strong> is to make a function that, no matter how it is called, is called with a particular this value”.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> cat <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">purr</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;meow&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="op">},</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="dt">purrMore</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">this</span>.<span class="at">purr</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="op">},</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="op">};</span></a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="kw">let</span> sayMeow <span class="op">=</span> <span class="va">cat</span>.<span class="at">purrMore</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="va">console</span>.<span class="at">log</span>(<span class="at">sayMeow</span>())<span class="op">;</span> <span class="co">// TypeError</span></a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="kw">let</span> boundCat <span class="op">=</span> <span class="va">sayMeow</span>.<span class="at">bind</span>(cat)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-14" title="14"></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="at">boundCat</span>()<span class="op">;</span> <span class="co">// prints &quot;meow&quot;</span></a></code></pre></div>
<p><strong>Binding with Arguments</strong></p>
<ul>
<li><p>We can also use bind() to bind arguments to a function.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">let</span> aboundFunc <span class="op">=</span> <span class="va">func</span>.<span class="at">bind</span>(context<span class="op">,</span> arg1<span class="op">,</span> arg2<span class="op">,</span> <span class="va">etc</span>...)<span class="op">;</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">const</span> sum <span class="op">=</span> <span class="kw">function</span> (a<span class="op">,</span> b) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">const</span> add3 <span class="op">=</span> <span class="va">sum</span>.<span class="at">bind</span>(<span class="kw">null</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add3</span>(<span class="dv">10</span>))<span class="op">;</span> <span class="co">// 13</span></a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">const</span> multiply <span class="op">=</span> <span class="kw">function</span> (a<span class="op">,</span> b) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="cf">return</span> a <span class="op">*</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">const</span> double <span class="op">=</span> <span class="va">multiply</span>.<span class="at">bind</span>(<span class="kw">null</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">const</span> triple <span class="op">=</span> <span class="va">multiply</span>.<span class="at">bind</span>(<span class="kw">null</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="va">console</span>.<span class="at">log</span>(<span class="at">double</span>(<span class="dv">3</span>))<span class="op">;</span> <span class="co">// 6</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="at">triple</span>(<span class="dv">3</span>))<span class="op">;</span> <span class="co">// 9</span></a></code></pre></div></li>
</ul>
<hr />
<h2 id="arrow-functions-aka-fat-arrows"><strong>Arrow Functions aka Fat Arrows</strong></h2>
<ul>
<li><strong><code>=&gt;</code></strong> : A more concise way of declaring a function and also considers the behavior of <code>this</code> and context.</li>
</ul>
<p><strong>Arrow Functions Solving Problems</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> average <span class="op">=</span> <span class="kw">function</span> (num1<span class="op">,</span> num2) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">let</span> avg <span class="op">=</span> (num1 <span class="op">+</span> num2) / <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="cf">return</span> avg<span class="op">;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="op">};</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">let</span> averageArrow <span class="op">=</span> (num1<span class="op">,</span> num2) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="kw">let</span> avg <span class="op">=</span> (num1 <span class="op">+</span> num2) / <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="cf">return</span> avg<span class="op">;</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="op">};</span></a></code></pre></div>
<p>As you can see the arrow function is shorter and easier to read.</p>
<p><strong>Anatomy of an Arrow Function</strong></p>
<ul>
<li>If there is only a single parameter there is no need to add parenthesis before the arrow function.</li>
<li>However if there are zero parameters then you must add an empty set of parentheses.</li>
</ul>
<p><strong>Single Expression Arrow Functions</strong></p>
<ul>
<li>Arrow functions, <em>unlike</em> normal functions, carry over context, binding <code>this</code> lexically.</li>
<li>Value of <code>this</code> inside an arrow function is not dependent on how it is invoked.</li>
<li>Because arrow functions already have a <em>bound context</em>, you can’t reassign <code>this</code>.</li>
</ul>
<hr />
